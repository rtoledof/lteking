package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"

	"cubawheeler.io/cmd/driver/graph/model"
	"cubawheeler.io/pkg/client/auth"
	"cubawheeler.io/pkg/cubawheeler"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, otp string) (*model.Token, error) {
	value := url.Values{
		"grant_type": {"password"},
		"username":   {email},
		"password":   {otp},
	}

	var token model.Token

	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/login", r.authService), value)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}

	return &token, nil
}

// Otp is the resolver for the otp field.
func (r *mutationResolver) Otp(ctx context.Context, email string) (*model.Response, error) {
	var rsp = model.Response{
		Success: true,
		Code:    http.StatusOK,
	}
	value := url.Values{
		"email": {email},
	}

	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/otp", r.authService), value)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()

	var code string
	if err := json.NewDecoder(resp.Body).Decode(&code); err != nil {
		slog.Info("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	rsp.Message = code
	return &rsp, nil
}

// Authorize is the resolver for the authorize field.
func (r *mutationResolver) Authorize(ctx context.Context, clientID string, clientSecret string, refreshToken *string) (*model.Token, error) {
	value := url.Values{
		"grant_type":    {"client_credentials"},
		"client_id":     {clientID},
		"client_secret": {clientSecret},
	}
	if refreshToken != nil {
		value.Set("refresh_token", *refreshToken)
	}
	var token model.Token
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/authorize", r.authService), value)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	return &token, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, profile model.UpdateProfile) (*model.Response, error) {
	token := cubawheeler.JWTFromContext(ctx)
	if token == "" {
		return nil, fmt.Errorf("unable to update the profile: %w", cubawheeler.ErrAccessDenied)
	}
	transport := auth.AuthTransport{
		Token: token,
	}
	client, err := auth.NewClient(transport.Client(), r.authService)
	if err != nil {
		return nil, fmt.Errorf("error creating client: %v: %w", err, cubawheeler.ErrInternal)
	}
	var rsp = model.Response{
		Success: true,
		Code:    http.StatusOK,
		Message: "profile updated",
	}
	req := auth.UpdateProfile{}
	if profile.Name != nil {
		req.Name = *profile.Name
	}
	if profile.LastName != nil {
		req.LastName = *profile.LastName
	}
	if profile.Phone != nil {
		req.Phone = *profile.Phone
	}
	if profile.Dob != nil {
		req.Dob = *profile.Dob
	}
	if profile.Gender != nil {
		req.Gender = profile.Gender.String()
	}
	if profile.Photo != nil {
		req.Photo = *profile.Photo
	}
	if err := client.UpdateProfile(ctx, req); err != nil {
		rsp.Success = false
		rsp.Code = http.StatusInternalServerError
		rsp.Message = err.Error()
	}
	return &rsp, nil
}

// SetStatus is the resolver for the setStatus field.
func (r *mutationResolver) SetStatus(ctx context.Context, active *bool) (*model.Response, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	response := model.Response{
		Success: true,
		Code:    http.StatusNoContent,
	}
	value := url.Values{
		"active": []string{fmt.Sprintf("%t", *active)},
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/status", r.authService), value)
	if err != nil {
		response.Success = false
		response.Message = err.Error()
	}
	return &response, nil
}

// AddDevice is the resolver for the addDevice field.
func (r *mutationResolver) AddDevice(ctx context.Context, decive string) (*model.Response, error) {
	var response = model.Response{
		Success: true,
		Code:    http.StatusNoContent,
	}
	{
		token := cubawheeler.JWTFromContext(ctx)
		transport := auth.AuthTransport{
			Token: token,
		}
		client, err := auth.NewClient(transport.Client(), r.authService)
		if err != nil {
			return nil, fmt.Errorf("error creating client: %v: %w", err, cubawheeler.ErrInternal)
		}
		if err := client.AddDevice(ctx, decive); err != nil {
			response.Success = false
			response.Message = err.Error()
			response.Code = http.StatusInternalServerError
		}
	}
	return &response, nil
}

// AcceptOrder is the resolver for the acceptOrder field.
func (r *mutationResolver) AcceptOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s/accept", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s/cancel", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// FindOrder is the resolver for the findOrder field.
func (r *mutationResolver) FindOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, cubawheeler.ErrAccessDenied
	}
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders/%s", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// FinishOrder is the resolver for the finishOrder field.
func (r *mutationResolver) FinishOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s/complete", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// AddVehicle is the resolver for the addVehicle field.
func (r *mutationResolver) AddVehicle(ctx context.Context, input *model.AddVehicle) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	value := url.Values{
		"brand": []string{input.Brand},
		"model": []string{input.Model},
		"year":  []string{fmt.Sprintf("%d", input.Year)},
		"plate": []string{input.Plate},
		"color": input.Color,
		"seats": []string{fmt.Sprintf("%d", input.Seats)},
		"type":  []string{string(*input.Type)},
	}
	for _, v := range input.Facilities {
		value.Add("facilities", string(*v))
	}
	for _, v := range input.Photos {
		filePath := fmt.Sprintf("%s/%s-%s/%s", user.ID, input.Brand, input.Model, v.Filename)
		if err := r.uploader.Upload(v.File, filePath); err != nil {
			return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
		}
		value.Add("photos", filePath)
	}
	filePath := fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("operative_license", filePath)
	filePath = fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("technic_inspection", filePath)
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/vehicles", r.authService), value)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// UpdateVehicle is the resolver for the updateVehicle field.
func (r *mutationResolver) UpdateVehicle(ctx context.Context, id string, input *model.AddVehicle) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	value := url.Values{
		"brand": []string{input.Brand},
		"model": []string{input.Model},
		"year":  []string{fmt.Sprintf("%d", input.Year)},
		"plate": []string{input.Plate},
		"color": input.Color,
		"seats": []string{fmt.Sprintf("%d", input.Seats)},
		"type":  []string{string(*input.Type)},
	}
	for _, v := range input.Facilities {
		value.Add("facilities", string(*v))
	}
	for _, v := range input.Photos {
		filePath := fmt.Sprintf("%s/%s-%s/%s", user.ID, input.Brand, input.Model, v.Filename)
		if err := r.uploader.Upload(v.File, filePath); err != nil {
			return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
		}
		value.Add("photos", filePath)
	}
	filePath := fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("operative_license", filePath)
	filePath = fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("technic_inspection", filePath)
	resp, err := makeRequest(ctx, http.MethodPut, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), value)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// DeleteVehicle is the resolver for the deleteVehicle field.
func (r *mutationResolver) DeleteVehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	resp, err := makeRequest(ctx, http.MethodDelete, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return &model.Vehicle{}, nil
}

// ListVehicles is the resolver for the listVehicles field.
func (r *mutationResolver) ListVehicles(ctx context.Context) ([]*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}

	resp, err := makeRequest(ctx, http.MethodDelete, fmt.Sprintf("%s/v1/vehicles", r.authService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var vehicles []*model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicles); err != nil {
		return nil, err
	}
	return vehicles, nil
}

// Transfer is the resolver for the transfer field.
func (r *mutationResolver) Transfer(ctx context.Context, to string, amount int, currency string, typeArg model.TransferType) (*model.Transaction, error) {
	value := url.Values{
		"to":       []string{to},
		"amount":   []string{fmt.Sprintf("%d", amount)},
		"currency": []string{currency},
		"type":     []string{string(typeArg)},
	}
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/wallet/transfer", r.walletService), value)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	var transaction model.Transaction
	if err := json.NewDecoder(resp.Body).Decode(&transaction); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	return &transaction, nil
}

// ConfirmTransaction is the resolver for the confirmTransaction field.
func (r *mutationResolver) ConfirmTransaction(ctx context.Context, id string, pin string) (*model.Response, error) {
	var response = model.Response{
		Success: true,
		Code:    http.StatusNoContent,
	}

	value := url.Values{
		"pin": []string{pin},
		"id":  []string{id},
	}
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/wallet/transfer/confirm", r.walletService), value)
	if err != nil {
		response.Success = false
		response.Message = err.Error()
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusNoContent {
		response.Success = false
		response.Message = fmt.Sprintf("error confirming transaction: %s", resp.Status)
	}
	return &response, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.ProfileOutput, error) {
	token := cubawheeler.JWTFromContext(ctx)
	if token == "" {
		return nil, fmt.Errorf("unable to update the profile: %w", cubawheeler.ErrAccessDenied)
	}
	transport := auth.AuthTransport{
		Token: token,
	}
	client, err := auth.NewClient(transport.Client(), r.authService)
	if err != nil {
		return nil, fmt.Errorf("error creating client: %v: %w", err, cubawheeler.ErrInternal)
	}
	user, err := client.GetProfile(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting profile: %v: %w", err, cubawheeler.ErrInternal)
	}

	return assambleUser(user), nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context) (int, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/wallet", r.walletService), nil)
	if err != nil {
		return 0, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	var balance int
	if err := json.NewDecoder(resp.Body).Decode(&balance); err != nil {
		return 0, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	return balance, nil
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context) ([]*model.Transaction, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/wallet/transactions", r.walletService), nil)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	var transactions []*model.Transaction
	if err := json.NewDecoder(resp.Body).Decode(&transactions); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	return transactions, nil
}

// Vehicles is the resolver for the vehicles field.
func (r *queryResolver) Vehicles(ctx context.Context) ([]*model.Vehicle, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/vehicles", r.authService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicles []*model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicles); err != nil {
		return nil, err
	}
	return vehicles, nil
}

// Vehicle is the resolver for the vehicle field.
func (r *queryResolver) Vehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// Plan is the resolver for the plan field.
func (r *queryResolver) Plan(ctx context.Context, id string) (*model.Plan, error) {
	panic(fmt.Errorf("not implemented: Plan - plan"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders", r.orderService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var orders []*model.Order
	if err := json.NewDecoder(resp.Body).Decode(&orders); err != nil {
		return nil, err
	}
	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	response, err := http.Get(fmt.Sprintf("%s/%s", r.orderService, id))
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	var order model.Order
	if err := json.NewDecoder(response.Body).Decode(&order); err != nil {
		return nil, err
	}
	return &order, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
