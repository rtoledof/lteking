package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"

	"cubawheeler.io/cmd/driver/graph/model"
	"cubawheeler.io/pkg/cubawheeler"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginRequest) (*model.Token, error) {
	value := url.Values{
		"grant_type": {"password"},
		"username":   {*input.Email},
		"password":   {*input.Otp},
	}

	if input.RefreshToken != nil {
		value.Set("refresh_token", *input.RefreshToken)
	}

	var token model.Token

	req, err := http.NewRequest(http.MethodPost, fmt.Sprintf("%s/login", r.authService), bytes.NewBufferString(value.Encode()))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v: %w", err, cubawheeler.ErrInternal)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}

	return &token, nil
}

// Otp is the resolver for the otp field.
func (r *mutationResolver) Otp(ctx context.Context, email string) (*model.Response, error) {
	var rsp = model.Response{
		Success: true,
		Code:    http.StatusOK,
	}
	value := url.Values{
		"email": {email},
	}

	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/otp", r.authService), value)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()

	var code string
	if err := json.NewDecoder(resp.Body).Decode(&code); err != nil {
		slog.Info("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	rsp.Message = code
	return &rsp, nil
}

// Authorize is the resolver for the authorize field.
func (r *mutationResolver) Authorize(ctx context.Context, clientID string, clientSecret string) (*model.Token, error) {
	value := url.Values{
		"grant_type":    {"client_credentials"},
		"client_id":     {clientID},
		"client_secret": {clientSecret},
	}
	var token model.Token
	req, err := http.NewRequest(http.MethodPost, fmt.Sprintf("%s/authorize", r.authService), bytes.NewBufferString(value.Encode()))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v: %w", err, cubawheeler.ErrInternal)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		slog.Info("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrAccessDenied)
	}
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	return &token, nil
}

// SetStatus is the resolver for the setStatus field.
func (r *mutationResolver) SetStatus(ctx context.Context, active *bool) (*model.Response, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	response := model.Response{
		Success: true,
		Code:    http.StatusNoContent,
	}
	value := url.Values{
		"active": []string{fmt.Sprintf("%t", *active)},
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/status", r.authService), value)
	if err != nil {
		response.Success = false
		response.Message = err.Error()
	}
	return &response, nil
}

// AddDevice is the resolver for the addDevice field.
func (r *mutationResolver) AddDevice(ctx context.Context, decive string) (*model.Response, error) {
	var response = model.Response{
		Success: true,
		Code:    http.StatusNoContent,
	}
	value := url.Values{
		"device_id": []string{decive},
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/profile/device", r.authService), value)
	if err != nil {
		response.Success = false
		response.Message = err.Error()
		response.Code = http.StatusInternalServerError
		return nil, err
	}
	return &response, nil
}

// AcceptOrder is the resolver for the acceptOrder field.
func (r *mutationResolver) AcceptOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s/accept", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders/%s", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s/cancel", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders/%s", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// FindOrder is the resolver for the findOrder field.
func (r *mutationResolver) FindOrder(ctx context.Context, id string) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: FindOrder - findOrder"))
}

// FinishOrder is the resolver for the finishOrder field.
func (r *mutationResolver) FinishOrder(ctx context.Context, id string) (*model.Order, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	_, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/orders/%s", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders/%s", r.orderService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var order model.Order
	if err := json.NewDecoder(resp.Body).Decode(&order); err != nil {
		return nil, err
	}

	return &order, nil
}

// AddVehicle is the resolver for the addVehicle field.
func (r *mutationResolver) AddVehicle(ctx context.Context, input *model.AddVehicle) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	value := url.Values{
		"brand": []string{input.Brand},
		"model": []string{input.Model},
		"year":  []string{fmt.Sprintf("%d", input.Year)},
		"plate": []string{input.Plate},
		"color": input.Color,
		"seats": []string{fmt.Sprintf("%d", input.Seats)},
		"type":  []string{string(*input.Type)},
	}
	for _, v := range input.Facilities {
		value.Add("facilities", string(*v))
	}
	for _, v := range input.Photos {
		filePath := fmt.Sprintf("%s/%s-%s/%s", user.ID, input.Brand, input.Model, v.Filename)
		if err := r.uploader.Upload(v.File, filePath); err != nil {
			return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
		}
		value.Add("photos", filePath)
	}
	filePath := fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("operative_license", filePath)
	filePath = fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("technic_inspection", filePath)
	resp, err := makeRequest(ctx, http.MethodPost, fmt.Sprintf("%s/v1/vehicles", r.authService), value)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// UpdateVehicle is the resolver for the updateVehicle field.
func (r *mutationResolver) UpdateVehicle(ctx context.Context, id string, input *model.AddVehicle) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	value := url.Values{
		"brand": []string{input.Brand},
		"model": []string{input.Model},
		"year":  []string{fmt.Sprintf("%d", input.Year)},
		"plate": []string{input.Plate},
		"color": input.Color,
		"seats": []string{fmt.Sprintf("%d", input.Seats)},
		"type":  []string{string(*input.Type)},
	}
	for _, v := range input.Facilities {
		value.Add("facilities", string(*v))
	}
	for _, v := range input.Photos {
		filePath := fmt.Sprintf("%s/%s-%s/%s", user.ID, input.Brand, input.Model, v.Filename)
		if err := r.uploader.Upload(v.File, filePath); err != nil {
			return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
		}
		value.Add("photos", filePath)
	}
	filePath := fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("operative_license", filePath)
	filePath = fmt.Sprintf("%s/license/%s", user.ID, input.OperativeLicense.Filename)
	if err := r.uploader.Upload(input.OperativeLicense.File, filePath); err != nil {
		return nil, fmt.Errorf("error uploading file: %v: %w", err, cubawheeler.ErrInternal)
	}
	value.Add("technic_inspection", filePath)
	resp, err := makeRequest(ctx, http.MethodPut, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), value)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// DeleteVehicle is the resolver for the deleteVehicle field.
func (r *mutationResolver) DeleteVehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}
	resp, err := makeRequest(ctx, http.MethodDelete, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return &model.Vehicle{}, nil
}

// ListVehicles is the resolver for the listVehicles field.
func (r *mutationResolver) ListVehicles(ctx context.Context) ([]*model.Vehicle, error) {
	user := cubawheeler.UserFromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unable to add the vehicle: %w", cubawheeler.ErrAccessDenied)
	}

	resp, err := makeRequest(ctx, http.MethodDelete, fmt.Sprintf("%s/v1/vehicles", r.authService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var vehicles []*model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicles); err != nil {
		return nil, err
	}
	return vehicles, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	resp, err := makeRequest(ctx, http.MethodGet, r.authService, nil)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v: %w", err, cubawheeler.ErrInternal)
	}
	defer resp.Body.Close()
	var profile cubawheeler.Profile
	if err := json.NewDecoder(resp.Body).Decode(&profile); err != nil {
		return nil, fmt.Errorf("error decoding response: %v: %w", err, cubawheeler.ErrInternal)
	}
	user := cubawheeler.UserFromContext(ctx)
	user.Profile = profile
	cubawheeler.NewContextWithUser(ctx, user)

	return assambleUser(user), nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context) (int, error) {
	panic(fmt.Errorf("not implemented: Balance - balance"))
}

// Vehicles is the resolver for the vehicles field.
func (r *queryResolver) Vehicles(ctx context.Context) ([]*model.Vehicle, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/vehicles", r.authService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicles []*model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicles); err != nil {
		return nil, err
	}
	return vehicles, nil
}

// Vehicle is the resolver for the vehicle field.
func (r *queryResolver) Vehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/vehicles/%s", r.authService, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var vehicle model.Vehicle
	if err := json.NewDecoder(resp.Body).Decode(&vehicle); err != nil {
		return nil, err
	}
	return &vehicle, nil
}

// Plan is the resolver for the plan field.
func (r *queryResolver) Plan(ctx context.Context, id string) (*model.Plan, error) {
	panic(fmt.Errorf("not implemented: Plan - plan"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	resp, err := makeRequest(ctx, http.MethodGet, fmt.Sprintf("%s/v1/orders", r.orderService), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var orders []*model.Order
	if err := json.NewDecoder(resp.Body).Decode(&orders); err != nil {
		return nil, err
	}
	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	response, err := http.Get(fmt.Sprintf("%s/%s", r.orderService, id))
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	var order model.Order
	if err := json.NewDecoder(response.Body).Decode(&order); err != nil {
		return nil, err
	}
	return &order, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context) ([]*model.Payment, error) {
	panic(fmt.Errorf("not implemented: Payments - payments"))
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	panic(fmt.Errorf("not implemented: Payment - payment"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
