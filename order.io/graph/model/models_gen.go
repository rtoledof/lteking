// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Category price
type CategoryPrice struct {
	// Category selected by the rider
	Category Category `json:"category"`
	// Price of the category
	Price float64 `json:"price"`
	// Currency of the price
	Currency string `json:"currency"`
}

// Input to confirm the ride and select the vategory and payment method
type ConfirmRideInput struct {
	// Order id
	ID string `json:"id"`
	// Selected Category
	Category Category `json:"category"`
	// Selected Payment method
	Method PaymentMethod `json:"method"`
}

type Error struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

// Item information used to request a ride
type Item struct {
	// List of the points for the route
	Points []*Point `json:"points"`
	// Coupon code if any
	Coupon *string `json:"coupon,omitempty"`
	// Number of riders
	Riders *int `json:"riders,omitempty"`
	// If the passenger has baggages
	Baggages *bool `json:"baggages,omitempty"`
	// Currency. Default currency is CUP
	Currency *string `json:"currency,omitempty"`
}

type Mutation struct {
}

// Order information. Contain all the information about the order.
type Order struct {
	// Unique identifier
	ID string `json:"id"`
	// List of the points for the route
	Items *Item `json:"items"`
	// Coupon code if any
	History []*Point `json:"history,omitempty"`
	// Number of riders
	Rider string `json:"rider"`
	// If the passenger has baggages
	Driver *string `json:"driver,omitempty"`
	// Currency. Default currency is CUP
	Status *OrderStatus `json:"status,omitempty"`
	// Status history
	StatusHistory []*OrderStatusHistory `json:"status_history,omitempty"`
	// Rate of the order
	Rate *float64 `json:"rate,omitempty"`
	// Comment of the order
	Price *int `json:"price,omitempty"`
	// Currency of the price
	Currency *string `json:"currency,omitempty"`
	// Creation date
	CreatedAt string `json:"created_at"`
	// Distance of the ride
	Distance *float64 `json:"distance,omitempty"`
	// Duration of the ride
	Duration *float64 `json:"duration,omitempty"`
	// Route of the ride
	Route *string `json:"route,omitempty"`
	// Payment method
	PaymentMethod *PaymentMethod `json:"payment_method,omitempty"`
	// Payment charge id
	ChargeID *string `json:"charge_id,omitempty"`
	// Payment charge id
	Category *Category `json:"category,omitempty"`
}

// Order list filter
type OrderListFilter struct {
	// Filter by status
	Status *OrderStatus `json:"status,omitempty"`
	// Filter by category
	Category *Category `json:"category,omitempty"`
	// Filter by payment method
	PaymentMethod *PaymentMethod `json:"payment_method,omitempty"`
	// Filter by date
	CreatedAt *string `json:"created_at,omitempty"`
	// Order list limit
	Limit *int `json:"limit,omitempty"`
	// Next page token
	Token *string `json:"token,omitempty"`
}

// Order status history
type OrderStatusHistory struct {
	// Status that the order was
	Status OrderStatus `json:"status"`
	// Timestamp of the status change
	Timestamp string `json:"timestamp"`
}

type OrdersResponse struct {
	// List of the orders
	Items []*Order `json:"items"`
	// Next page token
	Token string `json:"token"`
}

// Point information used to request a ride
type Point struct {
	// Latitude
	Lat float64 `json:"lat"`
	// Longitude
	Lng float64 `json:"lng"`
}

// Input point information used to request a ride
type PointInput struct {
	// Latitude
	Lat float64 `json:"lat"`
	// Longitude
	Lng float64 `json:"lng"`
}

type Query struct {
}

type Response struct {
	Success bool     `json:"success"`
	Message *string  `json:"message,omitempty"`
	Errors  []*Error `json:"errors,omitempty"`
}

// Input item information used to request a ride
type RideInput struct {
	// List of the points for the route
	Item []*PointInput `json:"item"`
	// Coupon code if any
	Coupon *string `json:"coupon,omitempty"`
	// Number of riders
	Riders *int `json:"riders,omitempty"`
	// If the passenger has baggages
	Baggages *bool `json:"baggages,omitempty"`
	// Currency. Default currency is CUP
	Currency *string `json:"currency,omitempty"`
}

// Card categories
type Category string

const (
	CategoryX        Category = "X"
	CategoryXl       Category = "XL"
	CategoryConfort  Category = "Confort"
	CategoryGreen    Category = "Green"
	CategoryPets     Category = "Pets"
	CategoryPackage  Category = "Package"
	CategoryPriority Category = "Priority"
)

var AllCategory = []Category{
	CategoryX,
	CategoryXl,
	CategoryConfort,
	CategoryGreen,
	CategoryPets,
	CategoryPackage,
	CategoryPriority,
}

func (e Category) IsValid() bool {
	switch e {
	case CategoryX, CategoryXl, CategoryConfort, CategoryGreen, CategoryPets, CategoryPackage, CategoryPriority:
		return true
	}
	return false
}

func (e Category) String() string {
	return string(e)
}

func (e *Category) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Category(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Category", str)
	}
	return nil
}

func (e Category) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order status enum
type OrderStatus string

const (
	OrderStatusNew           OrderStatus = "NEW"
	OrderStatusPending       OrderStatus = "PENDING"
	OrderStatusAccepted      OrderStatus = "ACCEPTED"
	OrderStatusPickedUp      OrderStatus = "PICKED_UP"
	OrderStatusDelivered     OrderStatus = "DELIVERED"
	OrderStatusCancelled     OrderStatus = "CANCELLED"
	OrderStatusWaitingDriver OrderStatus = "WAITING_DRIVER"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusNew,
	OrderStatusPending,
	OrderStatusAccepted,
	OrderStatusPickedUp,
	OrderStatusDelivered,
	OrderStatusCancelled,
	OrderStatusWaitingDriver,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusNew, OrderStatusPending, OrderStatusAccepted, OrderStatusPickedUp, OrderStatusDelivered, OrderStatusCancelled, OrderStatusWaitingDriver:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available payment method
type PaymentMethod string

const (
	PaymentMethodCash           PaymentMethod = "Cash"
	PaymentMethodCard           PaymentMethod = "Card"
	PaymentMethodBank           PaymentMethod = "Bank"
	PaymentMethodPaypal         PaymentMethod = "Paypal"
	PaymentMethodBitcoin        PaymentMethod = "Bitcoin"
	PaymentMethodEthereum       PaymentMethod = "Ethereum"
	PaymentMethodBalance        PaymentMethod = "Balance"
	PaymentMethodCUPTransaction PaymentMethod = "CUPTransaction"
	PaymentMethodMLCTransaction PaymentMethod = "MLCTransaction"
)

var AllPaymentMethod = []PaymentMethod{
	PaymentMethodCash,
	PaymentMethodCard,
	PaymentMethodBank,
	PaymentMethodPaypal,
	PaymentMethodBitcoin,
	PaymentMethodEthereum,
	PaymentMethodBalance,
	PaymentMethodCUPTransaction,
	PaymentMethodMLCTransaction,
}

func (e PaymentMethod) IsValid() bool {
	switch e {
	case PaymentMethodCash, PaymentMethodCard, PaymentMethodBank, PaymentMethodPaypal, PaymentMethodBitcoin, PaymentMethodEthereum, PaymentMethodBalance, PaymentMethodCUPTransaction, PaymentMethodMLCTransaction:
		return true
	}
	return false
}

func (e PaymentMethod) String() string {
	return string(e)
}

func (e *PaymentMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethod", str)
	}
	return nil
}

func (e PaymentMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
